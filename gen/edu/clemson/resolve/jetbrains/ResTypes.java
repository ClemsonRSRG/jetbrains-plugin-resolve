// This is a generated file. Not intended for manual editing.
package edu.clemson.resolve.jetbrains;

import com.intellij.psi.tree.IElementType;
import com.intellij.psi.PsiElement;
import com.intellij.lang.ASTNode;
import edu.clemson.resolve.jetbrains.psi.ResCompositeElementType;
import edu.clemson.resolve.jetbrains.psi.ResTokenType;
import edu.clemson.resolve.jetbrains.psi.impl.*;

public interface ResTypes {

  IElementType ARGUMENT_LIST = new ResCompositeElementType("ARGUMENT_LIST");
  IElementType ASSIGN_STATEMENT = new ResCompositeElementType("ASSIGN_STATEMENT");
  IElementType CALL_EXP = new ResCompositeElementType("CALL_EXP");
  IElementType CHANGING_CLAUSE = new ResCompositeElementType("CHANGING_CLAUSE");
  IElementType CLOSE_IDENTIFIER = new ResCompositeElementType("CLOSE_IDENTIFIER");
  IElementType CONCEPT_BLOCK = new ResCompositeElementType("CONCEPT_BLOCK");
  IElementType CONCEPT_EXTENSION_MODULE_DECL = new ResCompositeElementType("CONCEPT_EXTENSION_MODULE_DECL");
  IElementType CONCEPT_MODULE_DECL = new ResCompositeElementType("CONCEPT_MODULE_DECL");
  IElementType CONSTRAINTS_CLAUSE = new ResCompositeElementType("CONSTRAINTS_CLAUSE");
  IElementType CONVENTIONS_CLAUSE = new ResCompositeElementType("CONVENTIONS_CLAUSE");
  IElementType CORRESPONDENCE_CLAUSE = new ResCompositeElementType("CORRESPONDENCE_CLAUSE");
  IElementType DECREASING_CLAUSE = new ResCompositeElementType("DECREASING_CLAUSE");
  IElementType ELSE_STATEMENT = new ResCompositeElementType("ELSE_STATEMENT");
  IElementType ENSURES_CLAUSE = new ResCompositeElementType("ENSURES_CLAUSE");
  IElementType ENTAILS_CLAUSE = new ResCompositeElementType("ENTAILS_CLAUSE");
  IElementType EXEMPLAR_DECL = new ResCompositeElementType("EXEMPLAR_DECL");
  IElementType EXP = new ResCompositeElementType("EXP");
  IElementType EXTENSION_PAIRING = new ResCompositeElementType("EXTENSION_PAIRING");
  IElementType FACILITY_BLOCK = new ResCompositeElementType("FACILITY_BLOCK");
  IElementType FACILITY_DECL = new ResCompositeElementType("FACILITY_DECL");
  IElementType FACILITY_MODULE_DECL = new ResCompositeElementType("FACILITY_MODULE_DECL");
  IElementType FIELD_DEF = new ResCompositeElementType("FIELD_DEF");
  IElementType FIELD_VAR_DECL_GROUP = new ResCompositeElementType("FIELD_VAR_DECL_GROUP");
  IElementType IF_STATEMENT = new ResCompositeElementType("IF_STATEMENT");
  IElementType IMPL_BLOCK = new ResCompositeElementType("IMPL_BLOCK");
  IElementType IMPL_MODULE_DECL = new ResCompositeElementType("IMPL_MODULE_DECL");
  IElementType IMPL_MODULE_PARAMETERS = new ResCompositeElementType("IMPL_MODULE_PARAMETERS");
  IElementType INFIX_EXP = new ResCompositeElementType("INFIX_EXP");
  IElementType INTIALIZATION_CLAUSE = new ResCompositeElementType("INTIALIZATION_CLAUSE");
  IElementType LITERAL_EXP = new ResCompositeElementType("LITERAL_EXP");
  IElementType MAINTAINING_CLAUSE = new ResCompositeElementType("MAINTAINING_CLAUSE");
  IElementType MATH_ALTERNATIVES_LIST = new ResCompositeElementType("MATH_ALTERNATIVES_LIST");
  IElementType MATH_ALTERNATIVE_EXP = new ResCompositeElementType("MATH_ALTERNATIVE_EXP");
  IElementType MATH_ALTERNATIVE_ITEM_EXP = new ResCompositeElementType("MATH_ALTERNATIVE_ITEM_EXP");
  IElementType MATH_ASSERTION_EXP = new ResCompositeElementType("MATH_ASSERTION_EXP");
  IElementType MATH_CART_PROD_EXP = new ResCompositeElementType("MATH_CART_PROD_EXP");
  IElementType MATH_CATEGORICAL_DEFN_DECL = new ResCompositeElementType("MATH_CATEGORICAL_DEFN_DECL");
  IElementType MATH_CLSSFTN_ASSRT_EXP = new ResCompositeElementType("MATH_CLSSFTN_ASSRT_EXP");
  IElementType MATH_CLSSFTN_COROLLARY_DECL = new ResCompositeElementType("MATH_CLSSFTN_COROLLARY_DECL");
  IElementType MATH_EXP = new ResCompositeElementType("MATH_EXP");
  IElementType MATH_FUNCTION_APP_LIST = new ResCompositeElementType("MATH_FUNCTION_APP_LIST");
  IElementType MATH_INCOMING_EXP = new ResCompositeElementType("MATH_INCOMING_EXP");
  IElementType MATH_INDUCTIVE_DEFN_DECL = new ResCompositeElementType("MATH_INDUCTIVE_DEFN_DECL");
  IElementType MATH_INFIX_APPLY_EXP = new ResCompositeElementType("MATH_INFIX_APPLY_EXP");
  IElementType MATH_INFIX_DEFN_SIG = new ResCompositeElementType("MATH_INFIX_DEFN_SIG");
  IElementType MATH_LAMBDA_EXP = new ResCompositeElementType("MATH_LAMBDA_EXP");
  IElementType MATH_NESTED_EXP = new ResCompositeElementType("MATH_NESTED_EXP");
  IElementType MATH_NON_STD_APPLY_EXP = new ResCompositeElementType("MATH_NON_STD_APPLY_EXP");
  IElementType MATH_OUTFIX_APPLY_EXP = new ResCompositeElementType("MATH_OUTFIX_APPLY_EXP");
  IElementType MATH_OUTFIX_DEFN_SIG = new ResCompositeElementType("MATH_OUTFIX_DEFN_SIG");
  IElementType MATH_POSTFIX_DEFN_SIG = new ResCompositeElementType("MATH_POSTFIX_DEFN_SIG");
  IElementType MATH_PREFIX_APPLY_EXP = new ResCompositeElementType("MATH_PREFIX_APPLY_EXP");
  IElementType MATH_PREFIX_DEFN_SIG = new ResCompositeElementType("MATH_PREFIX_DEFN_SIG");
  IElementType MATH_QUANTIFIED_EXP = new ResCompositeElementType("MATH_QUANTIFIED_EXP");
  IElementType MATH_REFERENCE_EXP = new ResCompositeElementType("MATH_REFERENCE_EXP");
  IElementType MATH_SELECTOR_EXP = new ResCompositeElementType("MATH_SELECTOR_EXP");
  IElementType MATH_SET_RESTRICTION_EXP = new ResCompositeElementType("MATH_SET_RESTRICTION_EXP");
  IElementType MATH_STANDARD_DEFN_DECL = new ResCompositeElementType("MATH_STANDARD_DEFN_DECL");
  IElementType MATH_SYMBOL_NAME = new ResCompositeElementType("MATH_SYMBOL_NAME");
  IElementType MATH_THEOREM_DECL = new ResCompositeElementType("MATH_THEOREM_DECL");
  IElementType MATH_VAR_DECL = new ResCompositeElementType("MATH_VAR_DECL");
  IElementType MATH_VAR_DECL_GROUP = new ResCompositeElementType("MATH_VAR_DECL_GROUP");
  IElementType MATH_VAR_DEF = new ResCompositeElementType("MATH_VAR_DEF");
  IElementType MODULE_ARG_LIST = new ResCompositeElementType("MODULE_ARG_LIST");
  IElementType MODULE_IDENTIFIER = new ResCompositeElementType("MODULE_IDENTIFIER");
  IElementType MODULE_IDENTIFIER_SPEC = new ResCompositeElementType("MODULE_IDENTIFIER_SPEC");
  IElementType MODULE_LIBRARY_IDENTIFIER = new ResCompositeElementType("MODULE_LIBRARY_IDENTIFIER");
  IElementType NESTED_EXP = new ResCompositeElementType("NESTED_EXP");
  IElementType OPERATION_DECL = new ResCompositeElementType("OPERATION_DECL");
  IElementType OPERATION_PROCEDURE_DECL = new ResCompositeElementType("OPERATION_PROCEDURE_DECL");
  IElementType OP_BLOCK = new ResCompositeElementType("OP_BLOCK");
  IElementType PARAMETER_MODE = new ResCompositeElementType("PARAMETER_MODE");
  IElementType PARAM_DECL = new ResCompositeElementType("PARAM_DECL");
  IElementType PARAM_DEF = new ResCompositeElementType("PARAM_DEF");
  IElementType PRECIS_BLOCK = new ResCompositeElementType("PRECIS_BLOCK");
  IElementType PRECIS_EXTENSION_MODULE_DECL = new ResCompositeElementType("PRECIS_EXTENSION_MODULE_DECL");
  IElementType PRECIS_MODULE_DECL = new ResCompositeElementType("PRECIS_MODULE_DECL");
  IElementType PROCEDURE_DECL = new ResCompositeElementType("PROCEDURE_DECL");
  IElementType PROG_SYMBOL_NAME = new ResCompositeElementType("PROG_SYMBOL_NAME");
  IElementType RECORD_TYPE = new ResCompositeElementType("RECORD_TYPE");
  IElementType RECORD_VAR_DECL_GROUP = new ResCompositeElementType("RECORD_VAR_DECL_GROUP");
  IElementType REFERENCE_EXP = new ResCompositeElementType("REFERENCE_EXP");
  IElementType REQUIRES_CLAUSE = new ResCompositeElementType("REQUIRES_CLAUSE");
  IElementType SELECTOR_EXP = new ResCompositeElementType("SELECTOR_EXP");
  IElementType SHORT_FACILITY_MODULE_DECL = new ResCompositeElementType("SHORT_FACILITY_MODULE_DECL");
  IElementType SIMPLE_STATEMENT = new ResCompositeElementType("SIMPLE_STATEMENT");
  IElementType SPEC_MODULE_PARAMETERS = new ResCompositeElementType("SPEC_MODULE_PARAMETERS");
  IElementType STATEMENT = new ResCompositeElementType("STATEMENT");
  IElementType SWAP_STATEMENT = new ResCompositeElementType("SWAP_STATEMENT");
  IElementType TYPE = new ResCompositeElementType("TYPE");
  IElementType TYPE_IMPL_INIT = new ResCompositeElementType("TYPE_IMPL_INIT");
  IElementType TYPE_MODEL_DECL = new ResCompositeElementType("TYPE_MODEL_DECL");
  IElementType TYPE_PARAM_DECL = new ResCompositeElementType("TYPE_PARAM_DECL");
  IElementType TYPE_REFERENCE_EXP = new ResCompositeElementType("TYPE_REFERENCE_EXP");
  IElementType TYPE_REPR_DECL = new ResCompositeElementType("TYPE_REPR_DECL");
  IElementType USES_LIST = new ResCompositeElementType("USES_LIST");
  IElementType VAR_DECL_GROUP = new ResCompositeElementType("VAR_DECL_GROUP");
  IElementType VAR_DEF = new ResCompositeElementType("VAR_DEF");
  IElementType VAR_SPEC = new ResCompositeElementType("VAR_SPEC");
  IElementType WHILE_STATEMENT = new ResCompositeElementType("WHILE_STATEMENT");

  IElementType ALTERS = new ResTokenType("alters");
  IElementType AS = new ResTokenType("as");
  IElementType AT = new ResTokenType("@");
  IElementType BACKTICK = new ResTokenType("`");
  IElementType BASE = new ResTokenType("base");
  IElementType BY = new ResTokenType("by");
  IElementType CART_PROD = new ResTokenType("Cart_Prod");
  IElementType CATEGORICAL = new ResTokenType("Categorical");
  IElementType CHAINABLE = new ResTokenType("Chainable");
  IElementType CHANGING = new ResTokenType("changing");
  IElementType CHAR = new ResTokenType("char");
  IElementType CLASSIFICATION = new ResTokenType("Classification");
  IElementType CLEARS = new ResTokenType("clears");
  IElementType COLON = new ResTokenType(":");
  IElementType COLON_COLON = new ResTokenType("::");
  IElementType COLON_EQUALS = new ResTokenType(":=");
  IElementType COLON_EQUALS_COLON = new ResTokenType(":=:");
  IElementType COMMA = new ResTokenType(",");
  IElementType CONCEPT = new ResTokenType("Concept");
  IElementType CONSTRAINTS = new ResTokenType("constraints");
  IElementType CONVENTIONS = new ResTokenType("conventions");
  IElementType COROLLARY = new ResTokenType("Corollary");
  IElementType CORRESPONDENCE = new ResTokenType("correspondence");
  IElementType DBL_LBRACE = new ResTokenType("{{");
  IElementType DBL_RBRACE = new ResTokenType("}}");
  IElementType DECREASING = new ResTokenType("decreasing");
  IElementType DEFINES = new ResTokenType("Defines");
  IElementType DEFINITION = new ResTokenType("Definition");
  IElementType DO = new ResTokenType("do");
  IElementType DOT = new ResTokenType(".");
  IElementType DOT_DOT = new ResTokenType("..");
  IElementType ELSE = new ResTokenType("else");
  IElementType END = new ResTokenType("end");
  IElementType ENSURES = new ResTokenType("ensures");
  IElementType EVALUATES = new ResTokenType("evaluates");
  IElementType EXEMPLAR = new ResTokenType("exemplar");
  IElementType EXISTS = new ResTokenType("Exists");
  IElementType EXISTS1 = new ResTokenType("∃");
  IElementType EXTENDED = new ResTokenType("extended");
  IElementType EXTENDED_BY = new ResTokenType("extended_by");
  IElementType EXTENSION = new ResTokenType("Extension");
  IElementType EXTERNALLY = new ResTokenType("externally");
  IElementType FACILITY = new ResTokenType("Facility");
  IElementType FALSE = new ResTokenType("false");
  IElementType FAMILY = new ResTokenType("family");
  IElementType FAMILY_TYPE = new ResTokenType("Type");
  IElementType FOR = new ResTokenType("for");
  IElementType FORALL = new ResTokenType("Forall");
  IElementType FORALL1 = new ResTokenType("∀");
  IElementType FROM = new ResTokenType("from");
  IElementType HYPER_COLON = new ResTokenType("⦂");
  IElementType HYPO = new ResTokenType("hypo");
  IElementType IDENTIFIER = new ResTokenType("identifier");
  IElementType IF = new ResTokenType("if");
  IElementType IFF = new ResTokenType("iff");
  IElementType IMPLEMENTATION = new ResTokenType("Implementation");
  IElementType IMPLEMENTED = new ResTokenType("implemented");
  IElementType IMPLICIT = new ResTokenType("Implicit");
  IElementType INDUCTIVE = new ResTokenType("Inductive");
  IElementType IND_BASE = new ResTokenType("(i.)");
  IElementType IND_HYPO = new ResTokenType("(ii.)");
  IElementType INITIALIZATION = new ResTokenType("initialization");
  IElementType INT = new ResTokenType("int");
  IElementType IS = new ResTokenType("is");
  IElementType LAMBDA = new ResTokenType("lambda");
  IElementType LAMBDA1 = new ResTokenType("λ");
  IElementType LBRACE = new ResTokenType("{");
  IElementType LPAREN = new ResTokenType("(");
  IElementType MAINTAINING = new ResTokenType("maintaining");
  IElementType MATH_SYMBOL = new ResTokenType("math_symbol");
  IElementType MODELED = new ResTokenType("modeled");
  IElementType OF = new ResTokenType("of");
  IElementType OPERATION = new ResTokenType("Operation");
  IElementType OTHERWISE = new ResTokenType("otherwise");
  IElementType PARAM_TYPE = new ResTokenType("type");
  IElementType PRECIS = new ResTokenType("Precis");
  IElementType PRESERVES = new ResTokenType("preserves");
  IElementType PRIME = new ResTokenType("′");
  IElementType PROCEDURE = new ResTokenType("Procedure");
  IElementType PROG_IF = new ResTokenType("If");
  IElementType QV = new ResTokenType("?");
  IElementType RBRACE = new ResTokenType("}");
  IElementType RECORD = new ResTokenType("Record");
  IElementType RECURSIVE = new ResTokenType("Recursive");
  IElementType REPLACES = new ResTokenType("replaces");
  IElementType REQUIRES = new ResTokenType("requires");
  IElementType RESTORES = new ResTokenType("restores");
  IElementType RESTRICTION_BAR = new ResTokenType("∣");
  IElementType RPAREN = new ResTokenType(")");
  IElementType SEMICOLON = new ResTokenType(";");
  IElementType STRING = new ResTokenType("string");
  IElementType SYMBOL = new ResTokenType("symbol");
  IElementType THEN = new ResTokenType("then");
  IElementType THEOREM = new ResTokenType("Theorem");
  IElementType TRIPLE_DOT = new ResTokenType("...");
  IElementType TRUE = new ResTokenType("true");
  IElementType UPDATES = new ResTokenType("updates");
  IElementType USES = new ResTokenType("uses");
  IElementType VAR = new ResTokenType("Var");
  IElementType WHICH_ENTAILS = new ResTokenType("which_entails");
  IElementType WHILE = new ResTokenType("While");
  IElementType WITH = new ResTokenType("with");

  class Factory {
    public static PsiElement createElement(ASTNode node) {
      IElementType type = node.getElementType();
       if (type == ARGUMENT_LIST) {
        return new ResArgumentListImpl(node);
      }
      else if (type == ASSIGN_STATEMENT) {
        return new ResAssignStatementImpl(node);
      }
      else if (type == CALL_EXP) {
        return new ResCallExpImpl(node);
      }
      else if (type == CHANGING_CLAUSE) {
        return new ResChangingClauseImpl(node);
      }
      else if (type == CLOSE_IDENTIFIER) {
        return new ResCloseIdentifierImpl(node);
      }
      else if (type == CONCEPT_BLOCK) {
        return new ResConceptBlockImpl(node);
      }
      else if (type == CONCEPT_EXTENSION_MODULE_DECL) {
        return new ResConceptExtensionModuleDeclImpl(node);
      }
      else if (type == CONCEPT_MODULE_DECL) {
        return new ResConceptModuleDeclImpl(node);
      }
      else if (type == CONSTRAINTS_CLAUSE) {
        return new ResConstraintsClauseImpl(node);
      }
      else if (type == CONVENTIONS_CLAUSE) {
        return new ResConventionsClauseImpl(node);
      }
      else if (type == CORRESPONDENCE_CLAUSE) {
        return new ResCorrespondenceClauseImpl(node);
      }
      else if (type == DECREASING_CLAUSE) {
        return new ResDecreasingClauseImpl(node);
      }
      else if (type == ELSE_STATEMENT) {
        return new ResElseStatementImpl(node);
      }
      else if (type == ENSURES_CLAUSE) {
        return new ResEnsuresClauseImpl(node);
      }
      else if (type == ENTAILS_CLAUSE) {
        return new ResEntailsClauseImpl(node);
      }
      else if (type == EXEMPLAR_DECL) {
        return new ResExemplarDeclImpl(node);
      }
      else if (type == EXP) {
        return new ResExpImpl(node);
      }
      else if (type == EXTENSION_PAIRING) {
        return new ResExtensionPairingImpl(node);
      }
      else if (type == FACILITY_BLOCK) {
        return new ResFacilityBlockImpl(node);
      }
      else if (type == FACILITY_DECL) {
        return new ResFacilityDeclImpl(node);
      }
      else if (type == FACILITY_MODULE_DECL) {
        return new ResFacilityModuleDeclImpl(node);
      }
      else if (type == FIELD_DEF) {
        return new ResFieldDefImpl(node);
      }
      else if (type == FIELD_VAR_DECL_GROUP) {
        return new ResFieldVarDeclGroupImpl(node);
      }
      else if (type == IF_STATEMENT) {
        return new ResIfStatementImpl(node);
      }
      else if (type == IMPL_BLOCK) {
        return new ResImplBlockImpl(node);
      }
      else if (type == IMPL_MODULE_DECL) {
        return new ResImplModuleDeclImpl(node);
      }
      else if (type == IMPL_MODULE_PARAMETERS) {
        return new ResImplModuleParametersImpl(node);
      }
      else if (type == INFIX_EXP) {
        return new ResInfixExpImpl(node);
      }
      else if (type == INTIALIZATION_CLAUSE) {
        return new ResIntializationClauseImpl(node);
      }
      else if (type == LITERAL_EXP) {
        return new ResLiteralExpImpl(node);
      }
      else if (type == MAINTAINING_CLAUSE) {
        return new ResMaintainingClauseImpl(node);
      }
      else if (type == MATH_ALTERNATIVES_LIST) {
        return new ResMathAlternativesListImpl(node);
      }
      else if (type == MATH_ALTERNATIVE_EXP) {
        return new ResMathAlternativeExpImpl(node);
      }
      else if (type == MATH_ALTERNATIVE_ITEM_EXP) {
        return new ResMathAlternativeItemExpImpl(node);
      }
      else if (type == MATH_ASSERTION_EXP) {
        return new ResMathAssertionExpImpl(node);
      }
      else if (type == MATH_CART_PROD_EXP) {
        return new ResMathCartProdExpImpl(node);
      }
      else if (type == MATH_CATEGORICAL_DEFN_DECL) {
        return new ResMathCategoricalDefnDeclImpl(node);
      }
      else if (type == MATH_CLSSFTN_ASSRT_EXP) {
        return new ResMathClssftnAssrtExpImpl(node);
      }
      else if (type == MATH_CLSSFTN_COROLLARY_DECL) {
        return new ResMathClssftnCorollaryDeclImpl(node);
      }
      else if (type == MATH_EXP) {
        return new ResMathExpImpl(node);
      }
      else if (type == MATH_FUNCTION_APP_LIST) {
        return new ResMathFunctionAppListImpl(node);
      }
      else if (type == MATH_INCOMING_EXP) {
        return new ResMathIncomingExpImpl(node);
      }
      else if (type == MATH_INDUCTIVE_DEFN_DECL) {
        return new ResMathInductiveDefnDeclImpl(node);
      }
      else if (type == MATH_INFIX_APPLY_EXP) {
        return new ResMathInfixApplyExpImpl(node);
      }
      else if (type == MATH_INFIX_DEFN_SIG) {
        return new ResMathInfixDefnSigImpl(node);
      }
      else if (type == MATH_LAMBDA_EXP) {
        return new ResMathLambdaExpImpl(node);
      }
      else if (type == MATH_NESTED_EXP) {
        return new ResMathNestedExpImpl(node);
      }
      else if (type == MATH_NON_STD_APPLY_EXP) {
        return new ResMathNonStdApplyExpImpl(node);
      }
      else if (type == MATH_OUTFIX_APPLY_EXP) {
        return new ResMathOutfixApplyExpImpl(node);
      }
      else if (type == MATH_OUTFIX_DEFN_SIG) {
        return new ResMathOutfixDefnSigImpl(node);
      }
      else if (type == MATH_POSTFIX_DEFN_SIG) {
        return new ResMathPostfixDefnSigImpl(node);
      }
      else if (type == MATH_PREFIX_APPLY_EXP) {
        return new ResMathPrefixApplyExpImpl(node);
      }
      else if (type == MATH_PREFIX_DEFN_SIG) {
        return new ResMathPrefixDefnSigImpl(node);
      }
      else if (type == MATH_QUANTIFIED_EXP) {
        return new ResMathQuantifiedExpImpl(node);
      }
      else if (type == MATH_REFERENCE_EXP) {
        return new ResMathReferenceExpImpl(node);
      }
      else if (type == MATH_SELECTOR_EXP) {
        return new ResMathSelectorExpImpl(node);
      }
      else if (type == MATH_SET_RESTRICTION_EXP) {
        return new ResMathSetRestrictionExpImpl(node);
      }
      else if (type == MATH_STANDARD_DEFN_DECL) {
        return new ResMathStandardDefnDeclImpl(node);
      }
      else if (type == MATH_SYMBOL_NAME) {
        return new ResMathSymbolNameImpl(node);
      }
      else if (type == MATH_THEOREM_DECL) {
        return new ResMathTheoremDeclImpl(node);
      }
      else if (type == MATH_VAR_DECL) {
        return new ResMathVarDeclImpl(node);
      }
      else if (type == MATH_VAR_DECL_GROUP) {
        return new ResMathVarDeclGroupImpl(node);
      }
      else if (type == MATH_VAR_DEF) {
        return new ResMathVarDefImpl(node);
      }
      else if (type == MODULE_ARG_LIST) {
        return new ResModuleArgListImpl(node);
      }
      else if (type == MODULE_IDENTIFIER) {
        return new ResModuleIdentifierImpl(node);
      }
      else if (type == MODULE_IDENTIFIER_SPEC) {
        return new ResModuleIdentifierSpecImpl(node);
      }
      else if (type == MODULE_LIBRARY_IDENTIFIER) {
        return new ResModuleLibraryIdentifierImpl(node);
      }
      else if (type == NESTED_EXP) {
        return new ResNestedExpImpl(node);
      }
      else if (type == OPERATION_DECL) {
        return new ResOperationDeclImpl(node);
      }
      else if (type == OPERATION_PROCEDURE_DECL) {
        return new ResOperationProcedureDeclImpl(node);
      }
      else if (type == OP_BLOCK) {
        return new ResOpBlockImpl(node);
      }
      else if (type == PARAMETER_MODE) {
        return new ResParameterModeImpl(node);
      }
      else if (type == PARAM_DECL) {
        return new ResParamDeclImpl(node);
      }
      else if (type == PARAM_DEF) {
        return new ResParamDefImpl(node);
      }
      else if (type == PRECIS_BLOCK) {
        return new ResPrecisBlockImpl(node);
      }
      else if (type == PRECIS_EXTENSION_MODULE_DECL) {
        return new ResPrecisExtensionModuleDeclImpl(node);
      }
      else if (type == PRECIS_MODULE_DECL) {
        return new ResPrecisModuleDeclImpl(node);
      }
      else if (type == PROCEDURE_DECL) {
        return new ResProcedureDeclImpl(node);
      }
      else if (type == PROG_SYMBOL_NAME) {
        return new ResProgSymbolNameImpl(node);
      }
      else if (type == RECORD_TYPE) {
        return new ResRecordTypeImpl(node);
      }
      else if (type == RECORD_VAR_DECL_GROUP) {
        return new ResRecordVarDeclGroupImpl(node);
      }
      else if (type == REFERENCE_EXP) {
        return new ResReferenceExpImpl(node);
      }
      else if (type == REQUIRES_CLAUSE) {
        return new ResRequiresClauseImpl(node);
      }
      else if (type == SELECTOR_EXP) {
        return new ResSelectorExpImpl(node);
      }
      else if (type == SHORT_FACILITY_MODULE_DECL) {
        return new ResShortFacilityModuleDeclImpl(node);
      }
      else if (type == SIMPLE_STATEMENT) {
        return new ResSimpleStatementImpl(node);
      }
      else if (type == SPEC_MODULE_PARAMETERS) {
        return new ResSpecModuleParametersImpl(node);
      }
      else if (type == STATEMENT) {
        return new ResStatementImpl(node);
      }
      else if (type == SWAP_STATEMENT) {
        return new ResSwapStatementImpl(node);
      }
      else if (type == TYPE) {
        return new ResTypeImpl(node);
      }
      else if (type == TYPE_IMPL_INIT) {
        return new ResTypeImplInitImpl(node);
      }
      else if (type == TYPE_MODEL_DECL) {
        return new ResTypeModelDeclImpl(node);
      }
      else if (type == TYPE_PARAM_DECL) {
        return new ResTypeParamDeclImpl(node);
      }
      else if (type == TYPE_REFERENCE_EXP) {
        return new ResTypeReferenceExpImpl(node);
      }
      else if (type == TYPE_REPR_DECL) {
        return new ResTypeReprDeclImpl(node);
      }
      else if (type == USES_LIST) {
        return new ResUsesListImpl(node);
      }
      else if (type == VAR_DECL_GROUP) {
        return new ResVarDeclGroupImpl(node);
      }
      else if (type == VAR_DEF) {
        return new ResVarDefImpl(node);
      }
      else if (type == VAR_SPEC) {
        return new ResVarSpecImpl(node);
      }
      else if (type == WHILE_STATEMENT) {
        return new ResWhileStatementImpl(node);
      }
      throw new AssertionError("Unknown element type: " + type);
    }
  }
}
