// This is a generated file. Not intended for manual editing.
package edu.clemson.resolve.jetbrains;

import com.intellij.psi.tree.IElementType;
import com.intellij.psi.PsiElement;
import com.intellij.lang.ASTNode;
import edu.clemson.resolve.jetbrains.psi.ResCompositeElementType;
import edu.clemson.resolve.jetbrains.psi.ResTokenType;
import edu.clemson.resolve.jetbrains.psi.impl.*;

public interface ResTypes {

  IElementType ADD_INFIX_EXP = new ResCompositeElementType("ADD_INFIX_EXP");
  IElementType AND_INFIX_EXP = new ResCompositeElementType("AND_INFIX_EXP");
  IElementType ARGUMENT_LIST = new ResCompositeElementType("ARGUMENT_LIST");
  IElementType ASSIGN_STATEMENT = new ResCompositeElementType("ASSIGN_STATEMENT");
  IElementType BOOLEAN_LITERAL = new ResCompositeElementType("BOOLEAN_LITERAL");
  IElementType CALL_EXP = new ResCompositeElementType("CALL_EXP");
  IElementType CHANGING_CLAUSE = new ResCompositeElementType("CHANGING_CLAUSE");
  IElementType CLOSE_IDENTIFIER = new ResCompositeElementType("CLOSE_IDENTIFIER");
  IElementType CONCEPT_BLOCK = new ResCompositeElementType("CONCEPT_BLOCK");
  IElementType CONCEPT_EXTENSION_MODULE_DECL = new ResCompositeElementType("CONCEPT_EXTENSION_MODULE_DECL");
  IElementType CONCEPT_MODULE_DECL = new ResCompositeElementType("CONCEPT_MODULE_DECL");
  IElementType CONSTRAINTS_CLAUSE = new ResCompositeElementType("CONSTRAINTS_CLAUSE");
  IElementType CONVENTIONS_CLAUSE = new ResCompositeElementType("CONVENTIONS_CLAUSE");
  IElementType CORRESPONDENCE_CLAUSE = new ResCompositeElementType("CORRESPONDENCE_CLAUSE");
  IElementType DECREASING_CLAUSE = new ResCompositeElementType("DECREASING_CLAUSE");
  IElementType ELSE_STATEMENT = new ResCompositeElementType("ELSE_STATEMENT");
  IElementType ENSURES_CLAUSE = new ResCompositeElementType("ENSURES_CLAUSE");
  IElementType ENTAILS_CLAUSE = new ResCompositeElementType("ENTAILS_CLAUSE");
  IElementType EXEMPLAR_DECL = new ResCompositeElementType("EXEMPLAR_DECL");
  IElementType EXP = new ResCompositeElementType("EXP");
  IElementType EXTENSION_PAIRING = new ResCompositeElementType("EXTENSION_PAIRING");
  IElementType FACILITY_BLOCK = new ResCompositeElementType("FACILITY_BLOCK");
  IElementType FACILITY_DECL = new ResCompositeElementType("FACILITY_DECL");
  IElementType FACILITY_MODULE_DECL = new ResCompositeElementType("FACILITY_MODULE_DECL");
  IElementType FIELD_DEF = new ResCompositeElementType("FIELD_DEF");
  IElementType FIELD_VAR_DECL_GROUP = new ResCompositeElementType("FIELD_VAR_DECL_GROUP");
  IElementType IF_STATEMENT = new ResCompositeElementType("IF_STATEMENT");
  IElementType IMPL_BLOCK = new ResCompositeElementType("IMPL_BLOCK");
  IElementType IMPL_MODULE_DECL = new ResCompositeElementType("IMPL_MODULE_DECL");
  IElementType IMPL_MODULE_PARAMETERS = new ResCompositeElementType("IMPL_MODULE_PARAMETERS");
  IElementType INTIALIZATION_CLAUSE = new ResCompositeElementType("INTIALIZATION_CLAUSE");
  IElementType LITERAL_EXP = new ResCompositeElementType("LITERAL_EXP");
  IElementType MAINTAINING_CLAUSE = new ResCompositeElementType("MAINTAINING_CLAUSE");
  IElementType MATH_ADD_INFIX_APPLY_EXP = new ResCompositeElementType("MATH_ADD_INFIX_APPLY_EXP");
  IElementType MATH_ALTERNATIVE_EXP = new ResCompositeElementType("MATH_ALTERNATIVE_EXP");
  IElementType MATH_ALTERNATIVE_ITEM_EXP = new ResCompositeElementType("MATH_ALTERNATIVE_ITEM_EXP");
  IElementType MATH_ANGLE_1_OUTFIX_APPLY_EXP = new ResCompositeElementType("MATH_ANGLE_1_OUTFIX_APPLY_EXP");
  IElementType MATH_ANGLE_OUTFIX_APPLY_EXP = new ResCompositeElementType("MATH_ANGLE_OUTFIX_APPLY_EXP");
  IElementType MATH_APPLICATION_INFIX_APPLY_EXP = new ResCompositeElementType("MATH_APPLICATION_INFIX_APPLY_EXP");
  IElementType MATH_ASSERTION_EXP = new ResCompositeElementType("MATH_ASSERTION_EXP");
  IElementType MATH_BAR_OUTFIX_APPLY_EXP = new ResCompositeElementType("MATH_BAR_OUTFIX_APPLY_EXP");
  IElementType MATH_BOOLEAN_INFIX_APPLY_EXP = new ResCompositeElementType("MATH_BOOLEAN_INFIX_APPLY_EXP");
  IElementType MATH_CART_PROD_EXP = new ResCompositeElementType("MATH_CART_PROD_EXP");
  IElementType MATH_CATEGORICAL_DEFN_DECL = new ResCompositeElementType("MATH_CATEGORICAL_DEFN_DECL");
  IElementType MATH_CUP_OUTFIX_APPLY_EXP = new ResCompositeElementType("MATH_CUP_OUTFIX_APPLY_EXP");
  IElementType MATH_DBL_BAR_OUTFIX_APPLY_EXP = new ResCompositeElementType("MATH_DBL_BAR_OUTFIX_APPLY_EXP");
  IElementType MATH_EQUALITY_INFIX_APPLY_EXP = new ResCompositeElementType("MATH_EQUALITY_INFIX_APPLY_EXP");
  IElementType MATH_EXP = new ResCompositeElementType("MATH_EXP");
  IElementType MATH_IDENT_INFIX_APPLY_EXP = new ResCompositeElementType("MATH_IDENT_INFIX_APPLY_EXP");
  IElementType MATH_IMPLIES_INFIX_APPLY_EXP = new ResCompositeElementType("MATH_IMPLIES_INFIX_APPLY_EXP");
  IElementType MATH_INCOMING_UNARY_APPLY_EXP = new ResCompositeElementType("MATH_INCOMING_UNARY_APPLY_EXP");
  IElementType MATH_INDUCTIVE_DEFN_DECL = new ResCompositeElementType("MATH_INDUCTIVE_DEFN_DECL");
  IElementType MATH_INFIX_DEFN_SIG = new ResCompositeElementType("MATH_INFIX_DEFN_SIG");
  IElementType MATH_JOINING_INFIX_APPLY_EXP = new ResCompositeElementType("MATH_JOINING_INFIX_APPLY_EXP");
  IElementType MATH_LAMBDA_EXP = new ResCompositeElementType("MATH_LAMBDA_EXP");
  IElementType MATH_LITERAL_EXP = new ResCompositeElementType("MATH_LITERAL_EXP");
  IElementType MATH_MULT_INFIX_APPLY_EXP = new ResCompositeElementType("MATH_MULT_INFIX_APPLY_EXP");
  IElementType MATH_NESTED_EXP = new ResCompositeElementType("MATH_NESTED_EXP");
  IElementType MATH_OUTFIX_DEFN_SIG = new ResCompositeElementType("MATH_OUTFIX_DEFN_SIG");
  IElementType MATH_POSTFIX_DEFN_SIG = new ResCompositeElementType("MATH_POSTFIX_DEFN_SIG");
  IElementType MATH_PREFIX_APPLY_EXP = new ResCompositeElementType("MATH_PREFIX_APPLY_EXP");
  IElementType MATH_PREFIX_DEFN_SIG = new ResCompositeElementType("MATH_PREFIX_DEFN_SIG");
  IElementType MATH_PREFIX_GENERALIZED_CEIL_APPLY_EXP = new ResCompositeElementType("MATH_PREFIX_GENERALIZED_CEIL_APPLY_EXP");
  IElementType MATH_PREFIX_GENERALIZED_SQBR_APPLY_EXP = new ResCompositeElementType("MATH_PREFIX_GENERALIZED_SQBR_APPLY_EXP");
  IElementType MATH_QUANTIFIED_EXP = new ResCompositeElementType("MATH_QUANTIFIED_EXP");
  IElementType MATH_REFERENCE_EXP = new ResCompositeElementType("MATH_REFERENCE_EXP");
  IElementType MATH_RELATIONAL_INFIX_APPLY_EXP = new ResCompositeElementType("MATH_RELATIONAL_INFIX_APPLY_EXP");
  IElementType MATH_SELECTOR_EXP = new ResCompositeElementType("MATH_SELECTOR_EXP");
  IElementType MATH_SET_COMPREHENSION_EXP = new ResCompositeElementType("MATH_SET_COMPREHENSION_EXP");
  IElementType MATH_SET_ELEMENTS_LIST = new ResCompositeElementType("MATH_SET_ELEMENTS_LIST");
  IElementType MATH_SET_EXP = new ResCompositeElementType("MATH_SET_EXP");
  IElementType MATH_SET_INFIX_APPLY_EXP = new ResCompositeElementType("MATH_SET_INFIX_APPLY_EXP");
  IElementType MATH_SQ_BR_OUTFIX_APPLY_EXP = new ResCompositeElementType("MATH_SQ_BR_OUTFIX_APPLY_EXP");
  IElementType MATH_STANDARD_DEFN_DECL = new ResCompositeElementType("MATH_STANDARD_DEFN_DECL");
  IElementType MATH_SYMBOL_NAME = new ResCompositeElementType("MATH_SYMBOL_NAME");
  IElementType MATH_THEOREM_DECL = new ResCompositeElementType("MATH_THEOREM_DECL");
  IElementType MATH_TYPE_ASSERTION_EXP = new ResCompositeElementType("MATH_TYPE_ASSERTION_EXP");
  IElementType MATH_VAR_DECL = new ResCompositeElementType("MATH_VAR_DECL");
  IElementType MATH_VAR_DECL_GROUP = new ResCompositeElementType("MATH_VAR_DECL_GROUP");
  IElementType MATH_VAR_DEF = new ResCompositeElementType("MATH_VAR_DEF");
  IElementType MODULE_ARG_LIST = new ResCompositeElementType("MODULE_ARG_LIST");
  IElementType MODULE_IDENTIFIER_SPEC = new ResCompositeElementType("MODULE_IDENTIFIER_SPEC");
  IElementType MODULE_LIBRARY_IDENTIFIER_SPEC = new ResCompositeElementType("MODULE_LIBRARY_IDENTIFIER_SPEC");
  IElementType MUL_INFIX_EXP = new ResCompositeElementType("MUL_INFIX_EXP");
  IElementType OPERATION_DECL = new ResCompositeElementType("OPERATION_DECL");
  IElementType OPERATION_PROCEDURE_DECL = new ResCompositeElementType("OPERATION_PROCEDURE_DECL");
  IElementType OP_BLOCK = new ResCompositeElementType("OP_BLOCK");
  IElementType OR_INFIX_EXP = new ResCompositeElementType("OR_INFIX_EXP");
  IElementType PARAMETER_MODE = new ResCompositeElementType("PARAMETER_MODE");
  IElementType PARAM_DECL = new ResCompositeElementType("PARAM_DECL");
  IElementType PARAM_DEF = new ResCompositeElementType("PARAM_DEF");
  IElementType PAREN_EXP = new ResCompositeElementType("PAREN_EXP");
  IElementType PRECIS_BLOCK = new ResCompositeElementType("PRECIS_BLOCK");
  IElementType PRECIS_EXTENSION_MODULE_DECL = new ResCompositeElementType("PRECIS_EXTENSION_MODULE_DECL");
  IElementType PRECIS_MODULE_DECL = new ResCompositeElementType("PRECIS_MODULE_DECL");
  IElementType PROCEDURE_DECL = new ResCompositeElementType("PROCEDURE_DECL");
  IElementType RECORD_TYPE = new ResCompositeElementType("RECORD_TYPE");
  IElementType RECORD_VAR_DECL_GROUP = new ResCompositeElementType("RECORD_VAR_DECL_GROUP");
  IElementType REFERENCE_EXP = new ResCompositeElementType("REFERENCE_EXP");
  IElementType RELATIONAL_INFIX_EXP = new ResCompositeElementType("RELATIONAL_INFIX_EXP");
  IElementType REQUIRES_CLAUSE = new ResCompositeElementType("REQUIRES_CLAUSE");
  IElementType SELECTOR_EXP = new ResCompositeElementType("SELECTOR_EXP");
  IElementType SIMPLE_STATEMENT = new ResCompositeElementType("SIMPLE_STATEMENT");
  IElementType SPEC_MODULE_PARAMETERS = new ResCompositeElementType("SPEC_MODULE_PARAMETERS");
  IElementType STATEMENT = new ResCompositeElementType("STATEMENT");
  IElementType STRING_LITERAL = new ResCompositeElementType("STRING_LITERAL");
  IElementType SWAP_STATEMENT = new ResCompositeElementType("SWAP_STATEMENT");
  IElementType TYPE = new ResCompositeElementType("TYPE");
  IElementType TYPE_IMPL_INIT = new ResCompositeElementType("TYPE_IMPL_INIT");
  IElementType TYPE_MODEL_DECL = new ResCompositeElementType("TYPE_MODEL_DECL");
  IElementType TYPE_PARAM_DECL = new ResCompositeElementType("TYPE_PARAM_DECL");
  IElementType TYPE_REFERENCE_EXP = new ResCompositeElementType("TYPE_REFERENCE_EXP");
  IElementType TYPE_REPR_DECL = new ResCompositeElementType("TYPE_REPR_DECL");
  IElementType UNARY_EXP = new ResCompositeElementType("UNARY_EXP");
  IElementType USES_LIST = new ResCompositeElementType("USES_LIST");
  IElementType USES_SPEC_GROUP = new ResCompositeElementType("USES_SPEC_GROUP");
  IElementType VAR_DECL_GROUP = new ResCompositeElementType("VAR_DECL_GROUP");
  IElementType VAR_DEF = new ResCompositeElementType("VAR_DEF");
  IElementType VAR_SPEC = new ResCompositeElementType("VAR_SPEC");
  IElementType WHILE_STATEMENT = new ResCompositeElementType("WHILE_STATEMENT");

  IElementType ALTERS = new ResTokenType("alters");
  IElementType AND = new ResTokenType("and");
  IElementType AS = new ResTokenType("as");
  IElementType AT = new ResTokenType("@");
  IElementType BAR = new ResTokenType("|");
  IElementType BASE = new ResTokenType("base");
  IElementType BY = new ResTokenType("by");
  IElementType CART_PROD = new ResTokenType("Cart_Prod");
  IElementType CAT = new ResTokenType("o");
  IElementType CAT1 = new ResTokenType("∘");
  IElementType CATEGORICAL = new ResTokenType("Categorical");
  IElementType CHANGING = new ResTokenType("changing");
  IElementType CHAR = new ResTokenType("char");
  IElementType CLEARS = new ResTokenType("clears");
  IElementType COLON = new ResTokenType(":");
  IElementType COLONCOLON = new ResTokenType("::");
  IElementType COLON_EQUALS = new ResTokenType(":=");
  IElementType COLON_EQUALS_COLON = new ResTokenType(":=:");
  IElementType COMMA = new ResTokenType(",");
  IElementType CONCEPT = new ResTokenType("Concept");
  IElementType CONSTRAINTS = new ResTokenType("constraints");
  IElementType CONVENTIONS = new ResTokenType("conventions");
  IElementType COROLLARY = new ResTokenType("Corollary");
  IElementType CORRESPONDENCE = new ResTokenType("correspondence");
  IElementType DBL_BAR = new ResTokenType("||");
  IElementType DBL_LBRACE = new ResTokenType("{{");
  IElementType DBL_RBRACE = new ResTokenType("}}");
  IElementType DECREASING = new ResTokenType("decreasing");
  IElementType DEFINES = new ResTokenType("Defines");
  IElementType DEFINITION = new ResTokenType("Definition");
  IElementType DO = new ResTokenType("do");
  IElementType DOT = new ResTokenType(".");
  IElementType DOT_DOT = new ResTokenType("..");
  IElementType ELSE = new ResTokenType("else");
  IElementType END = new ResTokenType("end");
  IElementType ENSURES = new ResTokenType("ensures");
  IElementType EQUALS = new ResTokenType("=");
  IElementType EVALUATES = new ResTokenType("evaluates");
  IElementType EXEMPLAR = new ResTokenType("exemplar");
  IElementType EXISTS = new ResTokenType("Exists");
  IElementType EXISTS1 = new ResTokenType("∃");
  IElementType EXTENDED = new ResTokenType("extended");
  IElementType EXTENDED_BY = new ResTokenType("extended_by");
  IElementType EXTENSION = new ResTokenType("Extension");
  IElementType EXTERNALLY = new ResTokenType("externally");
  IElementType FACILITY = new ResTokenType("Facility");
  IElementType FALSE = new ResTokenType("false");
  IElementType FAMILY = new ResTokenType("family");
  IElementType FAMILY_TYPE = new ResTokenType("Type");
  IElementType FOR = new ResTokenType("for");
  IElementType FORALL = new ResTokenType("Forall");
  IElementType FORALL1 = new ResTokenType("∀");
  IElementType FROM = new ResTokenType("from");
  IElementType GREATER = new ResTokenType(">");
  IElementType GREATER_OR_EQUAL = new ResTokenType(">=");
  IElementType GREATER_OR_EQUAL1 = new ResTokenType("≥");
  IElementType HTIMES = new ResTokenType("ᴴ⨯");
  IElementType HYPO = new ResTokenType("hypo");
  IElementType IDENTIFIER = new ResTokenType("identifier");
  IElementType IF = new ResTokenType("if");
  IElementType IFF = new ResTokenType("iff");
  IElementType IMPLEMENTATION = new ResTokenType("Implementation");
  IElementType IMPLEMENTED = new ResTokenType("implemented");
  IElementType IMPLICIT = new ResTokenType("Implicit");
  IElementType IMPLIES = new ResTokenType("implies");
  IElementType INDUCTIVE = new ResTokenType("Inductive");
  IElementType IND_BASE = new ResTokenType("(i.)");
  IElementType IND_HYPO = new ResTokenType("(ii.)");
  IElementType INITIALIZATION = new ResTokenType("initialization");
  IElementType INT = new ResTokenType("int");
  IElementType INTERSECT = new ResTokenType("intersect");
  IElementType INTERSECT1 = new ResTokenType("∩");
  IElementType INTERSECT_PLUS = new ResTokenType("∩₊");
  IElementType IS = new ResTokenType("is");
  IElementType IS_IN = new ResTokenType("is_in");
  IElementType IS_IN1 = new ResTokenType("∈");
  IElementType IS_NOT_IN = new ResTokenType("is_not_in");
  IElementType IS_NOT_IN1 = new ResTokenType("∉");
  IElementType LAMBDA = new ResTokenType("lambda");
  IElementType LAMBDA1 = new ResTokenType("λ");
  IElementType LANGLE = new ResTokenType("⟨");
  IElementType LBRACE = new ResTokenType("{");
  IElementType LBRACK = new ResTokenType("[");
  IElementType LCEIL = new ResTokenType("⎡");
  IElementType LCURVE = new ResTokenType("⎝");
  IElementType LESS = new ResTokenType("<");
  IElementType LESS_OR_EQUAL = new ResTokenType("<=");
  IElementType LESS_OR_EQUAL1 = new ResTokenType("≤");
  IElementType LESS_OR_EQUAL_U = new ResTokenType("≤ᵤ");
  IElementType LPAREN = new ResTokenType("(");
  IElementType MAINTAINING = new ResTokenType("maintaining");
  IElementType MINUS = new ResTokenType("-");
  IElementType MOD = new ResTokenType("%");
  IElementType MODELED = new ResTokenType("modeled");
  IElementType MUL = new ResTokenType("*");
  IElementType NEG = new ResTokenType("⌐");
  IElementType NEQUALS = new ResTokenType("/=");
  IElementType NEQUALS1 = new ResTokenType("≠");
  IElementType NOT = new ResTokenType("not");
  IElementType OF = new ResTokenType("of");
  IElementType OPERATION = new ResTokenType("Operation");
  IElementType OR = new ResTokenType("or");
  IElementType OTHERWISE = new ResTokenType("otherwise");
  IElementType PARAM_TYPE = new ResTokenType("type");
  IElementType PLUS = new ResTokenType("+");
  IElementType PRECCURLYEQ = new ResTokenType("≼");
  IElementType PRECIS = new ResTokenType("Precis");
  IElementType PRESERVES = new ResTokenType("preserves");
  IElementType PROCEDURE = new ResTokenType("Procedure");
  IElementType PROG_IF = new ResTokenType("If");
  IElementType QUOTIENT = new ResTokenType("/");
  IElementType RANGLE = new ResTokenType("⟩");
  IElementType RARROW = new ResTokenType("->");
  IElementType RARROW1 = new ResTokenType("⟶");
  IElementType RAW_STRING = new ResTokenType("raw_string");
  IElementType RBRACE = new ResTokenType("}");
  IElementType RBRACK = new ResTokenType("]");
  IElementType RCEIL = new ResTokenType("⎤");
  IElementType RCURVE = new ResTokenType("⎠");
  IElementType RECORD = new ResTokenType("Record");
  IElementType RECURSIVE = new ResTokenType("Recursive");
  IElementType REPLACES = new ResTokenType("replaces");
  IElementType REQUIRES = new ResTokenType("requires");
  IElementType RESTORES = new ResTokenType("restores");
  IElementType RPAREN = new ResTokenType(")");
  IElementType SEMICOLON = new ResTokenType(";");
  IElementType STRING = new ResTokenType("string");
  IElementType THEN = new ResTokenType("then");
  IElementType THEOREM = new ResTokenType("Theorem");
  IElementType TILDE = new ResTokenType("~");
  IElementType TIMES = new ResTokenType("⨯");
  IElementType TRIPLE_DOT = new ResTokenType("...");
  IElementType TRUE = new ResTokenType("true");
  IElementType UNION = new ResTokenType("union");
  IElementType UNION1 = new ResTokenType("∪");
  IElementType UNION_PLUS = new ResTokenType("∪₊");
  IElementType UPDATES = new ResTokenType("updates");
  IElementType USES = new ResTokenType("uses");
  IElementType VAR = new ResTokenType("Var");
  IElementType VROD = new ResTokenType("ϒ");
  IElementType WHICH_ENTAILS = new ResTokenType("which_entails");
  IElementType WHILE = new ResTokenType("While");
  IElementType WITH = new ResTokenType("with");

  class Factory {
    public static PsiElement createElement(ASTNode node) {
      IElementType type = node.getElementType();
       if (type == ADD_INFIX_EXP) {
        return new ResAddInfixExpImpl(node);
      }
      else if (type == AND_INFIX_EXP) {
        return new ResAndInfixExpImpl(node);
      }
      else if (type == ARGUMENT_LIST) {
        return new ResArgumentListImpl(node);
      }
      else if (type == ASSIGN_STATEMENT) {
        return new ResAssignStatementImpl(node);
      }
      else if (type == BOOLEAN_LITERAL) {
        return new ResBooleanLiteralImpl(node);
      }
      else if (type == CALL_EXP) {
        return new ResCallExpImpl(node);
      }
      else if (type == CHANGING_CLAUSE) {
        return new ResChangingClauseImpl(node);
      }
      else if (type == CLOSE_IDENTIFIER) {
        return new ResCloseIdentifierImpl(node);
      }
      else if (type == CONCEPT_BLOCK) {
        return new ResConceptBlockImpl(node);
      }
      else if (type == CONCEPT_EXTENSION_MODULE_DECL) {
        return new ResConceptExtensionModuleDeclImpl(node);
      }
      else if (type == CONCEPT_MODULE_DECL) {
        return new ResConceptModuleDeclImpl(node);
      }
      else if (type == CONSTRAINTS_CLAUSE) {
        return new ResConstraintsClauseImpl(node);
      }
      else if (type == CONVENTIONS_CLAUSE) {
        return new ResConventionsClauseImpl(node);
      }
      else if (type == CORRESPONDENCE_CLAUSE) {
        return new ResCorrespondenceClauseImpl(node);
      }
      else if (type == DECREASING_CLAUSE) {
        return new ResDecreasingClauseImpl(node);
      }
      else if (type == ELSE_STATEMENT) {
        return new ResElseStatementImpl(node);
      }
      else if (type == ENSURES_CLAUSE) {
        return new ResEnsuresClauseImpl(node);
      }
      else if (type == ENTAILS_CLAUSE) {
        return new ResEntailsClauseImpl(node);
      }
      else if (type == EXEMPLAR_DECL) {
        return new ResExemplarDeclImpl(node);
      }
      else if (type == EXP) {
        return new ResExpImpl(node);
      }
      else if (type == EXTENSION_PAIRING) {
        return new ResExtensionPairingImpl(node);
      }
      else if (type == FACILITY_BLOCK) {
        return new ResFacilityBlockImpl(node);
      }
      else if (type == FACILITY_DECL) {
        return new ResFacilityDeclImpl(node);
      }
      else if (type == FACILITY_MODULE_DECL) {
        return new ResFacilityModuleDeclImpl(node);
      }
      else if (type == FIELD_DEF) {
        return new ResFieldDefImpl(node);
      }
      else if (type == FIELD_VAR_DECL_GROUP) {
        return new ResFieldVarDeclGroupImpl(node);
      }
      else if (type == IF_STATEMENT) {
        return new ResIfStatementImpl(node);
      }
      else if (type == IMPL_BLOCK) {
        return new ResImplBlockImpl(node);
      }
      else if (type == IMPL_MODULE_DECL) {
        return new ResImplModuleDeclImpl(node);
      }
      else if (type == IMPL_MODULE_PARAMETERS) {
        return new ResImplModuleParametersImpl(node);
      }
      else if (type == INTIALIZATION_CLAUSE) {
        return new ResIntializationClauseImpl(node);
      }
      else if (type == LITERAL_EXP) {
        return new ResLiteralExpImpl(node);
      }
      else if (type == MAINTAINING_CLAUSE) {
        return new ResMaintainingClauseImpl(node);
      }
      else if (type == MATH_ADD_INFIX_APPLY_EXP) {
        return new ResMathAddInfixApplyExpImpl(node);
      }
      else if (type == MATH_ALTERNATIVE_EXP) {
        return new ResMathAlternativeExpImpl(node);
      }
      else if (type == MATH_ALTERNATIVE_ITEM_EXP) {
        return new ResMathAlternativeItemExpImpl(node);
      }
      else if (type == MATH_ANGLE_1_OUTFIX_APPLY_EXP) {
        return new ResMathAngle1OutfixApplyExpImpl(node);
      }
      else if (type == MATH_ANGLE_OUTFIX_APPLY_EXP) {
        return new ResMathAngleOutfixApplyExpImpl(node);
      }
      else if (type == MATH_APPLICATION_INFIX_APPLY_EXP) {
        return new ResMathApplicationInfixApplyExpImpl(node);
      }
      else if (type == MATH_ASSERTION_EXP) {
        return new ResMathAssertionExpImpl(node);
      }
      else if (type == MATH_BAR_OUTFIX_APPLY_EXP) {
        return new ResMathBarOutfixApplyExpImpl(node);
      }
      else if (type == MATH_BOOLEAN_INFIX_APPLY_EXP) {
        return new ResMathBooleanInfixApplyExpImpl(node);
      }
      else if (type == MATH_CART_PROD_EXP) {
        return new ResMathCartProdExpImpl(node);
      }
      else if (type == MATH_CATEGORICAL_DEFN_DECL) {
        return new ResMathCategoricalDefnDeclImpl(node);
      }
      else if (type == MATH_CUP_OUTFIX_APPLY_EXP) {
        return new ResMathCupOutfixApplyExpImpl(node);
      }
      else if (type == MATH_DBL_BAR_OUTFIX_APPLY_EXP) {
        return new ResMathDblBarOutfixApplyExpImpl(node);
      }
      else if (type == MATH_EQUALITY_INFIX_APPLY_EXP) {
        return new ResMathEqualityInfixApplyExpImpl(node);
      }
      else if (type == MATH_EXP) {
        return new ResMathExpImpl(node);
      }
      else if (type == MATH_IDENT_INFIX_APPLY_EXP) {
        return new ResMathIdentInfixApplyExpImpl(node);
      }
      else if (type == MATH_IMPLIES_INFIX_APPLY_EXP) {
        return new ResMathImpliesInfixApplyExpImpl(node);
      }
      else if (type == MATH_INCOMING_UNARY_APPLY_EXP) {
        return new ResMathIncomingUnaryApplyExpImpl(node);
      }
      else if (type == MATH_INDUCTIVE_DEFN_DECL) {
        return new ResMathInductiveDefnDeclImpl(node);
      }
      else if (type == MATH_INFIX_DEFN_SIG) {
        return new ResMathInfixDefnSigImpl(node);
      }
      else if (type == MATH_JOINING_INFIX_APPLY_EXP) {
        return new ResMathJoiningInfixApplyExpImpl(node);
      }
      else if (type == MATH_LAMBDA_EXP) {
        return new ResMathLambdaExpImpl(node);
      }
      else if (type == MATH_LITERAL_EXP) {
        return new ResMathLiteralExpImpl(node);
      }
      else if (type == MATH_MULT_INFIX_APPLY_EXP) {
        return new ResMathMultInfixApplyExpImpl(node);
      }
      else if (type == MATH_NESTED_EXP) {
        return new ResMathNestedExpImpl(node);
      }
      else if (type == MATH_OUTFIX_DEFN_SIG) {
        return new ResMathOutfixDefnSigImpl(node);
      }
      else if (type == MATH_POSTFIX_DEFN_SIG) {
        return new ResMathPostfixDefnSigImpl(node);
      }
      else if (type == MATH_PREFIX_APPLY_EXP) {
        return new ResMathPrefixApplyExpImpl(node);
      }
      else if (type == MATH_PREFIX_DEFN_SIG) {
        return new ResMathPrefixDefnSigImpl(node);
      }
      else if (type == MATH_PREFIX_GENERALIZED_CEIL_APPLY_EXP) {
        return new ResMathPrefixGeneralizedCeilApplyExpImpl(node);
      }
      else if (type == MATH_PREFIX_GENERALIZED_SQBR_APPLY_EXP) {
        return new ResMathPrefixGeneralizedSqbrApplyExpImpl(node);
      }
      else if (type == MATH_QUANTIFIED_EXP) {
        return new ResMathQuantifiedExpImpl(node);
      }
      else if (type == MATH_REFERENCE_EXP) {
        return new ResMathReferenceExpImpl(node);
      }
      else if (type == MATH_RELATIONAL_INFIX_APPLY_EXP) {
        return new ResMathRelationalInfixApplyExpImpl(node);
      }
      else if (type == MATH_SELECTOR_EXP) {
        return new ResMathSelectorExpImpl(node);
      }
      else if (type == MATH_SET_COMPREHENSION_EXP) {
        return new ResMathSetComprehensionExpImpl(node);
      }
      else if (type == MATH_SET_ELEMENTS_LIST) {
        return new ResMathSetElementsListImpl(node);
      }
      else if (type == MATH_SET_EXP) {
        return new ResMathSetExpImpl(node);
      }
      else if (type == MATH_SET_INFIX_APPLY_EXP) {
        return new ResMathSetInfixApplyExpImpl(node);
      }
      else if (type == MATH_SQ_BR_OUTFIX_APPLY_EXP) {
        return new ResMathSqBrOutfixApplyExpImpl(node);
      }
      else if (type == MATH_STANDARD_DEFN_DECL) {
        return new ResMathStandardDefnDeclImpl(node);
      }
      else if (type == MATH_SYMBOL_NAME) {
        return new ResMathSymbolNameImpl(node);
      }
      else if (type == MATH_THEOREM_DECL) {
        return new ResMathTheoremDeclImpl(node);
      }
      else if (type == MATH_TYPE_ASSERTION_EXP) {
        return new ResMathTypeAssertionExpImpl(node);
      }
      else if (type == MATH_VAR_DECL) {
        return new ResMathVarDeclImpl(node);
      }
      else if (type == MATH_VAR_DECL_GROUP) {
        return new ResMathVarDeclGroupImpl(node);
      }
      else if (type == MATH_VAR_DEF) {
        return new ResMathVarDefImpl(node);
      }
      else if (type == MODULE_ARG_LIST) {
        return new ResModuleArgListImpl(node);
      }
      else if (type == MODULE_IDENTIFIER_SPEC) {
        return new ResModuleIdentifierSpecImpl(node);
      }
      else if (type == MODULE_LIBRARY_IDENTIFIER_SPEC) {
        return new ResModuleLibraryIdentifierSpecImpl(node);
      }
      else if (type == MUL_INFIX_EXP) {
        return new ResMulInfixExpImpl(node);
      }
      else if (type == OPERATION_DECL) {
        return new ResOperationDeclImpl(node);
      }
      else if (type == OPERATION_PROCEDURE_DECL) {
        return new ResOperationProcedureDeclImpl(node);
      }
      else if (type == OP_BLOCK) {
        return new ResOpBlockImpl(node);
      }
      else if (type == OR_INFIX_EXP) {
        return new ResOrInfixExpImpl(node);
      }
      else if (type == PARAMETER_MODE) {
        return new ResParameterModeImpl(node);
      }
      else if (type == PARAM_DECL) {
        return new ResParamDeclImpl(node);
      }
      else if (type == PARAM_DEF) {
        return new ResParamDefImpl(node);
      }
      else if (type == PAREN_EXP) {
        return new ResParenExpImpl(node);
      }
      else if (type == PRECIS_BLOCK) {
        return new ResPrecisBlockImpl(node);
      }
      else if (type == PRECIS_EXTENSION_MODULE_DECL) {
        return new ResPrecisExtensionModuleDeclImpl(node);
      }
      else if (type == PRECIS_MODULE_DECL) {
        return new ResPrecisModuleDeclImpl(node);
      }
      else if (type == PROCEDURE_DECL) {
        return new ResProcedureDeclImpl(node);
      }
      else if (type == RECORD_TYPE) {
        return new ResRecordTypeImpl(node);
      }
      else if (type == RECORD_VAR_DECL_GROUP) {
        return new ResRecordVarDeclGroupImpl(node);
      }
      else if (type == REFERENCE_EXP) {
        return new ResReferenceExpImpl(node);
      }
      else if (type == RELATIONAL_INFIX_EXP) {
        return new ResRelationalInfixExpImpl(node);
      }
      else if (type == REQUIRES_CLAUSE) {
        return new ResRequiresClauseImpl(node);
      }
      else if (type == SELECTOR_EXP) {
        return new ResSelectorExpImpl(node);
      }
      else if (type == SIMPLE_STATEMENT) {
        return new ResSimpleStatementImpl(node);
      }
      else if (type == SPEC_MODULE_PARAMETERS) {
        return new ResSpecModuleParametersImpl(node);
      }
      else if (type == STATEMENT) {
        return new ResStatementImpl(node);
      }
      else if (type == STRING_LITERAL) {
        return new ResStringLiteralImpl(node);
      }
      else if (type == SWAP_STATEMENT) {
        return new ResSwapStatementImpl(node);
      }
      else if (type == TYPE) {
        return new ResTypeImpl(node);
      }
      else if (type == TYPE_IMPL_INIT) {
        return new ResTypeImplInitImpl(node);
      }
      else if (type == TYPE_MODEL_DECL) {
        return new ResTypeModelDeclImpl(node);
      }
      else if (type == TYPE_PARAM_DECL) {
        return new ResTypeParamDeclImpl(node);
      }
      else if (type == TYPE_REFERENCE_EXP) {
        return new ResTypeReferenceExpImpl(node);
      }
      else if (type == TYPE_REPR_DECL) {
        return new ResTypeReprDeclImpl(node);
      }
      else if (type == UNARY_EXP) {
        return new ResUnaryExpImpl(node);
      }
      else if (type == USES_LIST) {
        return new ResUsesListImpl(node);
      }
      else if (type == USES_SPEC_GROUP) {
        return new ResUsesSpecGroupImpl(node);
      }
      else if (type == VAR_DECL_GROUP) {
        return new ResVarDeclGroupImpl(node);
      }
      else if (type == VAR_DEF) {
        return new ResVarDefImpl(node);
      }
      else if (type == VAR_SPEC) {
        return new ResVarSpecImpl(node);
      }
      else if (type == WHILE_STATEMENT) {
        return new ResWhileStatementImpl(node);
      }
      throw new AssertionError("Unknown element type: " + type);
    }
  }
}
