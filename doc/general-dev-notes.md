# Some general language plugin development notes

Getting up and running, working-with, and keeping track of all the Jetbrains plugin support tools can make your head spin when starting development of a language plugin. The purpose of this doc is to simply point out some helpful tools for working with grammarkit `.bnf` style grammars, and to specify a process for prepping and maintaining the resulting grammar and lexer.

## Starting out: some helpful/required tools

First off, before doing anything, here are some **extremely** helpful (e.g.: pretty much essential) tools for doing any language plugin development work.

### Grammarkit 

[Grammarkit](https://github.com/JetBrains/Grammar-Kit) is currently the only "official" Jetbrains-backed tool for custom language development. I'll leave the specifics and tutorials to the readme on the project homepage, but essentially think of this tool as a means of generating a parser that produces a reasonably expressive, robust PSI (Program Structure Interface) tree from the programs users type -- which is really (from what I have gathered) the backbone of any non-trivial language plugin. 

Install by going to `Preferences` (OSX) (or `Settings` on Windows) > `Plugins` > `Browse Repositories` Then search for "grammarkit"/"grammar", etc. Or just download and install the zip from the Jetbrains online plugin repo [here](https://plugins.jetbrains.com/plugin/6606).

|**Note: ANTLR support**|
|-------------|
|*There is now upcoming support for ANTLR grammars in Jetbrains IDEs, though at the time of writing (~December 2015) support is still pretty shaky, and many useful features necessary to building a robust PSI are still not quite there -- so keep your eye on this and we can transition at some point in the future. Though for now, we'll eat the maintainability tradeoff posed by re-writing the RESOLVE grammar in favor of the nicer PSI's generated by the official Jetbrains tools. See  [this thread](https://devnet.jetbrains.com/thread/476061?tstart=0), [this sample language plugin](https://github.com/antlr/jetbrains-plugin-sample), and of course Terence Parr's jetbrains adaptor [project page](https://github.com/antlr/jetbrains).*|

### Psi viewer

Since you're likely going to spend most of your time typing in little sample programs and staring at the PSI structure that results, [psi viewer](https://plugins.jetbrains.com/plugin/227) is really helpful (follow the same installation procedure as provided for grammarkit).

Placing the caret anywhere in the editor, you can navigate through the hierarchy and check out the various properties of a given Psi node. It even allows you to filter whitespace, etc using the buttons at the top of the panel.

![psi viewer](https://github.com/Welchd1/jetbrains-plugin-resolve/blob/master/doc/images/psi-viewer.png)

### Shell script plugin

To compile the JFlex lexer we'll be using, it's helpful to install a plugin that allows you to easily run bash/shell scripts through IntelliJ's GUI. I happen to use [this one](https://plugins.jetbrains.com/plugin/4230?pr=idea), simply because it's the one IntelliJ suggests when viewing a raw `.sh` file for the first time -- though I'm sure there are a multitude of others that work just as well too. 

![run bash](https://github.com/Welchd1/jetbrains-plugin-resolve/blob/master/doc/images/run-bash.png)

## Howto: generating a jflex lexer and grammarkit parser for the *first time*

Given the tools listed above, now you want to get your parser and lexer generated properly. First, go ahead and create a folder at the top level of the project, right underneath `jetbrains-plugin-resolve`, named `gen` and be sure to mark it as a sources folder (if you've forgotten how to do this, re-read the end of the [contributing instructions](https://github.com/Welchd1/jetbrains-plugin-resolve/blob/master/doc/contributing-instructions.md)). 

**NOTE:** *Since this section assumes you're doing this for the first time, if there happens to already be a `gen` folder with things inside, go ahead and keep the `gen` folder, but delete all contents.*

Now simply right click on `Resolve.bnf` and select `Generate Parser Code`. Now open up the `gen` folder you created in the previous step and check to make sure that there are two folders (`parser`, `psi`), and a Java interface named `ResTypes`. While you're inside `gen`, go ahead and create another folder at the same level as the others named `lexer`.

Next we're going to generate an *intermediate* lexer. To do this, once again right click on `Resolve.bnf` and select `Generate JFlex Lexer`. The tool will ask you to select a folder where the generated lexer should go -- so put it in the empty `gen/lexer` folder we just made. You should now see a `ResLexer.flex` file sitting in the lexer directory we created, so now we generate a java recognizer from this by right clicking it and selecting `Run JFlex Generator`. 

Now, assuming you've installed the bash plugin mentioned in the previous section, we're going to generate the *real* lexer for our language by right clicking the `gen_lexer.sh` script (in `src/edu.clemson.resolve.jetbrains.lexer`) and pressing the green 'play' button (labeled `run 'gen_lexer.sh'`).

|**intermediate vs. real lexers**|
|-------------|
*If you're wondering why the hell I refer to the lexer as intermediate -- well apparently JFlex doesn't do the best job at automatically generating lexers from grammars, meaning it's better to handcode one (which is what we've done) -- we just need an intermediate one to hush up a bunch Java errors that come up when try to generate code our real lexer for the first time.*|

This will likely fail, due to some java errors in the generated file. So go ahead and comment out any lines causing errors in our real generated lexer then redo the previous step (meaning, re-run `gen_lexer.sh`) and the real lexer should then generate without issue -- replacing the fake, intermediate one we used earlier. If we hadn't gen'd the intermediate lexer, you'd have an unmanageable number of java errrors to comment out. 

## Why the hell is this last step so confusing?

Good question. I don't have a satisfactory answer other than I might be doing it wrong :). That being said, I have yet to find an easier way. The good news however is that you should be set to go, now that you have the real lexer generated, you can regenerate `Resolve.bnf` at will (and as long as you don't delete the `lexer` folder in `gen`, things should be pretty easy to update. 

To help eliminate the annoyances of this, I no longer ignore the `gen` folder in the `.gitignore`, so new contributors shouldn't have to contend with these annoyances. 

