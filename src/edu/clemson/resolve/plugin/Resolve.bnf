{
    parserClass='edu.clemson.resolve.plugin.parser.ResParser'

    implements='edu.clemson.resolve.plugin.psi.ResCompositeElement'
    extends='edu.clemson.resolve.plugin.psi.impl.ResCompositeElementImpl'
  
    elementTypeHolderClass='edu.clemson.resolve.plugin.ResTypes'
    elementTypeClass='edu.clemson.resolve.plugin.psi.ResCompositeElementType'
    tokenTypeClass='edu.clemson.resolve.plugin.psi.ResTokenType'
  
    psiClassPrefix='Res'
    psiImplClassSuffix='Impl'
    psiPackage='edu.clemson.resolve.plugin.psi'
    psiImplPackage='edu.clemson.resolve.plugin.psi.impl'
    psiImplUtilClass="edu.clemson.resolve.plugin.psi.impl.ResPsiImplUtil"
    //parserUtilClass="com.goide.parser.GoParserUtil"

    tokens=[
        LPAREN                  = "("
        RPAREN                  = ")"
        COLON                   = ":"
        DOT                     = '.'
        SEMICOLON               = ";"
        COMMA                   = ","
        EQUALS                  = "="

        //this 'space' is to make live preview less of a pain

        INT                     = "int"
        FACILITY                = "Facility"
        CONCEPT                 = "Concept"
        END                     = "end"
        EVALUATES               = "evaluates"
        USES                    = "uses"
        IS                      = "is"
        EXTERNALLY              = "externally"
        IMPLEMENTED             = "implemented"
        TYPE                    = "Type"
        FAMILY                  = "Family"
        MODELED                 = "modeled"
        EXEMPLAR                = "exemplar"
        OPERATION               = "Operation"
        RECURSIVE               = "Recursive"
        RECORD                  = "Record"
        PROCEDURE               = "Procedure"
        VAR                     = "Var"
        BY                      = "by"
        STRING                  = "string"
        LBRACE="{"
        RBRACE="}"
        raw_string              = "raw_string"
        space                   = "regexp:\s+"
        identifier              = 'regexp:\p{Alpha}\w*'
    ]

    extends("(Facility|Concept)Module")="edu.clemson.resolve.plugin.psi.impl.ResAbstractModuleImpl"
    extends("(OperationProcedure)Decl")="edu.clemson.resolve.plugin.psi.impl.ResOperationLikeNodeImpl"
    extends("(Facility)Decl|(Uses)Spec")="edu.clemson.resolve.plugin.psi.impl.ResNamedElementImpl"
    //extends("(Var|Param)Def|(Facility)Decl|(Uses)Spec")="edu.clemson.resolve.plugin.psi.impl.ResNamedElementImpl"

    implements("(Facility|Concept)Block")="edu.clemson.resolve.plugin.psi.ResModuleBlock"
    implements("(OperationProcedure)Decl")="edu.clemson.resolve.plugin.psi.ResOperationLikeNode"
    implements("(Var|Param)Def|(Facility)Decl|(Uses)Spec")="edu.clemson.resolve.plugin.psi.ResNamedElement"
    implements("(Facility|Concept)Module")="edu.clemson.resolve.plugin.psi.ResModule"
    generateTokenAccessors=true
}

Module ::= FacilityModule <<eof>>

FacilityModule ::= 'Facility' identifier ';'
UsesList?
FacilityBlock
'end' identifier ';' {pin(".*")=1}

UsesList ::= 'uses' UsesSpec (',' UsesSpec)* ';' {pin=1 recoverWhile=UsesListRecover}
private UsesListRecover ::= !('uses'|FacilityItem|'end' identifier)

UsesSpec ::= identifier

FacilityBlock ::= FacilityItem*

private FacilityItem ::= FacilityDecl | OperationProcedureDecl {recoverWhile="FacilityItemRecover"}

private FacilityItemRecover ::= !( 'end' |'Facility' | 'Operation')

FacilityDecl ::= 'Facility' identifier ';' {pin=2}

OperationProcedureDecl ::= 'Operation' identifier ';' {pin=2}
