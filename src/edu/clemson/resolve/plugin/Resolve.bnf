{
    parserClass='edu.clemson.resolve.plugin.parser.ResParser'

    implements='edu.clemson.resolve.plugin.psi.ResCompositeElement'
    extends='edu.clemson.resolve.plugin.psi.impl.ResCompositeElementImpl'
  
    elementTypeHolderClass='edu.clemson.resolve.plugin.ResTypes'
    elementTypeClass='edu.clemson.resolve.plugin.psi.ResCompositeElementType'
    tokenTypeClass='edu.clemson.resolve.plugin.psi.ResTokenType'
  
    psiClassPrefix='Res'
    psiImplClassSuffix='Impl'
    psiPackage='edu.clemson.resolve.plugin.psi'
    psiImplPackage='edu.clemson.resolve.plugin.psi.impl'
    psiImplUtilClass="edu.clemson.resolve.plugin.psi.impl.ResPsiImplUtil"
    //parserUtilClass="com.goide.parser.GoParserUtil"

    tokens=[
        LPAREN                  = "("
        RPAREN                  = ")"
        COLON                   = ":"
        DOT                     = '.'
        SEMICOLON               = ";"
        COMMA                   = ","

        //this 'space' is to make live preview less of a pain
        space                   = "regexp:\s+"

        INT                     = "int"
        FACILITY                = "Facility"
        CONCEPT                 = "Concept"
        END                     = "end"
        USES                    = "uses"
        IS                      = "is"
        EXTERNALLY              = "externally"
        IMPLEMENTED             = "implemented"
        TYPE                    = "Type"
        FAMILY                  = "Family"
        MODELED                 = "modeled"
        EXEMPLAR                = "exemplar"
        OPERATION               = "Operation"
        RECURSIVE               = "Recursive"
        PROCEDURE               = "Procedure"
        BY                      = "by"
        STRING                  = "string"
        raw_string              = "raw_string"
    ]

    extends("(Facility|Concept)Module")="edu.clemson.resolve.plugin.psi.impl.ResAbstractModuleImpl"
    extends("(TypeModel)Decl")="edu.clemson.resolve.plugin.psi.impl.ResAbstractTypeDeclImpl"
    extends("(OperationProcedure)Decl")="edu.clemson.resolve.plugin.psi.impl.ResOperationLikeNodeImpl"
    extends("(Facility)Decl|(Uses)Spec")="edu.clemson.resolve.plugin.psi.impl.ResNamedElementImpl"

    implements("(OperationProcedure)Decl")="edu.clemson.resolve.plugin.psi.ResOperationLikeNode"
    implements("(TypeModel)Decl")="edu.clemson.resolve.plugin.psi.ResTypeLikeNodeDecl"
    implements("(Facility)Decl|(Uses)Spec")="edu.clemson.resolve.plugin.psi.ResNamedElement"
    implements("(Facility|Concept)Module")="edu.clemson.resolve.plugin.psi.ResModule"
    implements(".*ReferenceExpression")="edu.clemson.resolve.plugin.psi.ResReferenceExpressionBase"

    /*extends("(Or|Add|Conversion|Mul|Selector)Expr")=BinaryExpr
    extends(".*(Expr|Literal|Lit|OperandName)")=Expression

    implements("(Type|Import)Spec|(Var|Const|Param|(Anonymous)?Field|Label)Definition|Receiver")="com.goide.psi.GoNamedElement"
    implements("FunctionLit")="com.goide.psi.GoSignatureOwner"
    implements("MethodSpec")="com.goide.psi.GoNamedSignatureOwner"
    implements("(Function|Method)Declaration")="com.goide.psi.GoFunctionOrMethodDeclaration"
    implements("(Const|Type|Var)Declaration")="com.goide.psi.GoTopLevelDeclaration"
    implements(".*ReferenceExpression|FieldName")="com.goide.psi.GoReferenceExpressionBase"
    extends("(Function|Method)Declaration")="com.goide.psi.impl.GoFunctionOrMethodDeclarationImpl<?>"
    extends("(Type|Import|Method)Spec|(Var|Const|Param|(Anonymous)?Field|Label)Definition|Receiver")="com.goide.psi.impl.GoNamedElementImpl<?>"
    extends("Parameters|Signature|ParameterDeclaration|Result|Type|(Const|Var|Import)Spec")="com.goide.psi.impl.GoStubbedElementImpl<?>"
    elementTypeFactory("(Function|Method|Parameter)Declaration|(Type|Import|Method|Const|Var)Spec|RangeClause|RecvStatement|ShortVarDeclaration|(Var|Const|Param|(Anonymous)?Field|Label)Definition|Receiver|Parameters|Signature|Result|.*Type|TypeList.*")='com.goide.stubs.GoStubElementTypeFactory.factory'
    pin(".*Statement")=1
    extends(".*Statement")=Statement
    extends(".*Type|TypeList")=Type*/
  
    generateTokenAccessors=true
}

Module ::= FacilityModule | ConceptModule <<eof>>

FacilityModule ::= FACILITY identifier SEMICOLON
    (UsesList)?
    (FacilityDecl | OperationProcedureDecl)* //add alts here
END identifier SEMICOLON {pin(".*")=1}

ConceptModule ::= CONCEPT identifier SEMICOLON
    (TypeModelDecl)*
END identifier SEMICOLON {pin(".*")=1}

UsesList ::= USES UsesSpec (COMMA UsesSpec)* SEMICOLON {pin=1}

UsesSpec ::= identifier {methods=[getUsesTextRange getReferences resolve]}

FacilityDecl ::= FACILITY identifier IS UsesSpec
(EXTERNALLY)? IMPLEMENTED BY UsesSpec SEMICOLON {pin=2}

TypeModelDecl ::= TYPE FAMILY identifier IS MODELED BY identifier semicolon
EXEMPLAR identifier semicolon {pin(".*")=3}

OperationProcedureDecl ::= OPERATION identifier LPAREN RPAREN COLON TypeRefNode
(RECURSIVE)? PROCEDURE END identifier semicolon {pin=2}

TypeRefNode ::= TypeReferenceExpression QualifiedTypeReferenceExpression?
TypeReferenceExpression ::= identifier { methods=[getReference getQualifier] }
left QualifiedTypeReferenceExpression ::= '.' identifier {elementType=TypeReferenceExpression}

Expression ::= LPAREN RPAREN //dummy
