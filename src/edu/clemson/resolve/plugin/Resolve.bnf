{
    parserClass='edu.clemson.resolve.plugin.parser.ResParser'

    implements='edu.clemson.resolve.plugin.psi.ResCompositeElement'
    extends='edu.clemson.resolve.plugin.psi.impl.ResCompositeElementImpl'

    elementTypeHolderClass='edu.clemson.resolve.plugin.ResTypes'
    elementTypeClass='edu.clemson.resolve.plugin.psi.ResCompositeElementType'
    tokenTypeClass='edu.clemson.resolve.plugin.psi.ResTokenType'

    psiClassPrefix='Res'
    psiImplClassSuffix='Impl'
    psiPackage='edu.clemson.resolve.plugin.psi'
    psiImplPackage='edu.clemson.resolve.plugin.psi.impl'
    psiImplUtilClass="edu.clemson.resolve.plugin.psi.impl.ResPsiImplUtil"
    //parserUtilClass="edu.clemson.resolve.plugin.RESOLVEParserUtil" //not needed yet..

    tokens=[
        // Punctuation
        AT                      = '@'
        TRIPLE_DOT              = '...'
        DOT_DOT                 = '..'
        DOT                     = '.'
        DBL_LBRACE              = '{{'
        LBRACE                  = '{'
        RBRACE                  = '}'
        DBL_RBRACE              = '}}'
        LBRACK                  = '['
        RBRACK                  = ']'
        LPAREN                  = '('
        RPAREN                  = ')'
        COLON                   = ':'
        SEMICOLON               = ';'
        COMMA                   = ','

        // Operators
        EQUALS                  = '='
        NEQUALS                 = '/='

        AND                     = 'and'
        OR                      = 'or'
        NOT                     = 'not'
        CAT                     = 'o'

        LESS_OR_EQUAL           = '<='
        LESS                    = '<'
        GREATER_OR_EQUAL        = '>='
        GREATER                 = '>'

        MOD                     = '%'
        MUL                     = '*'
        QUOTIENT                = '/'
        PLUS_PLUS               = '++'
        PLUS                    = '+'
        MINUS_MINUS             = '--'
        MINUS                   = '-'

        COLON_EQUALS            = ':='
        COLON_EQUALS_COLON      = ':=:'
        RARROW                  = '->'
        TILDE                   = '~'
        UNION                   = 'union'
        INTERSECT               = 'intersect'
        IS_IN                   = 'is_in'
        IS_NOT_IN               = 'is_not_in'
        BAR                     = '|'
        DBL_BAR                 = '||'

        // Keywords
        INT                     = 'int'
        FACILITY                = 'Facility'
        CONCEPT                 = 'Concept'
        CONSTRAINT              = 'constraints'
        END                     = 'end'
        USES                    = 'uses'
        IS                      = 'is'
        EXTERNALLY              = 'externally'
        IMPLEMENTED             = 'implemented'
        INITIALIZATION          = 'initialization'
        LAMBDA                  = 'lambda'
        TYPE                    = 'Type'
        PARAM_TYPE              = 'type'
        FAMILY                  = 'Family'
        MODELED                 = 'modeled'
        EXEMPLAR                = 'exemplar'
        OPERATION               = 'Operation'
        RECURSIVE               = 'Recursive'
        RECORD                  = 'Record'
        REQUIRES                = 'requires'
        ENSURES                 = 'ensures'
        PROCEDURE               = 'Procedure'
        VAR                     = 'Var'
        BY                      = 'by'
        WHILE                   = 'While'
        DO                      = 'do'
        STRING                  = 'string'
        WHICH_ENTAILS           = 'which_entails'
        CHAR                    = 'char'
        raw_string              = 'raw_string'

        // Parameter modes
        ALTERS                  = 'alters'
        UPDATES                 = 'updates'
        CLEARS                  = 'clears'
        RESTORES                = 'restores'
        PRESERVES               = 'preserves'
        REPLACES                = 'replaces'
        EVALUATES               = 'evaluates'

        //these two are for grammarkit's live preview feature work right,
        //disregard them otherwise
        space                   = "regexp:\s+"
        identifier              = 'regexp:\p{Alpha}\w*'
    ]

    extends("(Facility|Concept)ModuleDecl")="edu.clemson.resolve.plugin.psi.impl.ResAbstractModuleDeclImpl"
    extends("(OperationProcedure)Decl")="edu.clemson.resolve.plugin.psi.impl.ResOperationLikeNodeImpl"
    extends("(Facility)Decl|(Uses)Spec")="edu.clemson.resolve.plugin.psi.impl.ResNamedElementImpl"
    extends("(Param|Var)Def")="edu.clemson.resolve.plugin.psi.impl.ResNamedElementImpl"
    extends("(TypeModel|TypeRepr)Decl")="edu.clemson.resolve.plugin.psi.impl.ResAbstractTypeLikeDeclImpl"

    implements(".*ReferenceExpression")="edu.clemson.resolve.plugin.psi.ResReferenceExpressionBase"
    implements("(TypeModel|TypeRepr)Decl")="edu.clemson.resolve.plugin.psi.ResTypeLikeNodeDecl"
    implements("(Facility|Concept)Block")="edu.clemson.resolve.plugin.psi.ResModuleBlock"
    implements("(OperationProcedure)Decl")="edu.clemson.resolve.plugin.psi.ResOperationLikeNode"
    implements("(Var|Param)Def|(Facility)Decl|(Uses)Spec")="edu.clemson.resolve.plugin.psi.ResNamedElement"
    implements("(Facility|Concept)ModuleDecl")="edu.clemson.resolve.plugin.psi.ResModuleDecl"
    generateTokenAccessors=true
    pin('.*List(?:_\d.*)?')=1
}

ModuleDecl ::= FacilityModuleDecl | ConceptModuleDecl <<eof>>

FacilityModuleDecl ::= 'Facility' identifier ';'
UsesList?
FacilityBlock
'end' identifier ';' {pin(".*")=1}

ConceptModuleDecl ::= 'Concept' identifier SpecModuleParameters? ';'
UsesList?
ConceptBlock
'end' identifier ';' {pin(".*")=1}

UsesList ::= 'uses' UsesSpec (',' UsesSpec)* ';'

UsesSpec ::= identifier {methods=[getReferences resolve getUsesTextRange]}

FacilityBlock ::= FacilityItem* {methods=[processDeclarations] recoverWhile=ItemsRecover}

ConceptBlock ::= ConceptItem* {methods=[processDeclarations] recoverWhile=ItemsRecover}

private ItemsRecover ::= !('end')

private FacilityItem ::=
        OperationProcedureDecl
    |   FacilityDecl
    |   TypeReprDecl {pin=1 recoverWhile=FacilityItemRecover}

private FacilityItemRecover ::= !('Operation'|'Facility'|'Type'|'end')

private ConceptItem ::=
        TypeModelDecl
    |   OperationDecl {pin=1 recoverWhile=ConceptItemRecover}

private ConceptItemRecover ::= !('Type'|'Operation'|'end')

FacilityDecl ::= 'Facility' identifier 'is' UsesSpec
('externally')? 'implemented' 'by' UsesSpec ';' {pin=2} //TODO: enhancements!

TypeModelDecl ::= 'Type' 'Family' identifier 'is' 'modeled' 'by' identifier ';'
    'exemplar' identifier ';' {pin=3}

TypeReprDecl ::= 'Type' identifier '='
(TypeRefNode | RecordTypeNode) ';' {pin=2}

OperationProcedureDecl ::= 'Operation' identifier Signature ';'
ProcedureBody
'end' identifier ';' {pin=1}

Signature ::= OperationLikeParameters Result? {pin=1}

Result ::= ':' TypeRefNode {pin=1}

OperationDecl ::= 'Operation' identifier Signature ';' {pin=1}

SpecModuleParameters ::= '(' SpecModuleParamList ')' {pin=1 }

private SpecModuleParamList ::= SpecParamDecl  (';' SpecParamDecl)* {pin=2 recoverWhile=SpecListRec}

private SpecListRec ::= !(')')

SpecParamDecl ::= TypeParamDecl | ParamDecl

TypeParamDecl ::= 'type' identifier {pin=2}

OperationLikeParameters ::= '(' OpParamList? ')' { pin=1}
private ParamListRec ::= !(')')
OpParamList ::= ParamDecl (';' ParamDecl)* {pin=1 recoverWhile=ParamListRec}
ParamDecl ::= ParameterMode ParamDefinitionListNoPin ':' TypeRefNode {pin=1}
private ParamDefinitionListNoPin ::= ParamDef &(!(';'|')')) (',' ParamDef)* {pin=1}
ParamDef ::= identifier //{methods = [isVariadic]}

ProcedureBody ::= ('Recursive')?'Procedure'
VarDeclGroupList

ProcedureRec ::= !('end')

VarDeclGroupList ::= VarDeclGroup* {pin=1 recoverWhile=ProcedureRec}

RecordVarDeclGroup ::= VarSpec ';' {pin=1}

VarDeclGroup ::= 'Var' VarSpec ';' {pin=1}
VarSpec ::= VarDefList ':' TypeRefNode //{methods=[processDeclarations]}
private VarDefList ::= VarDef (',' VarDef)*

VarDef ::= identifier {methods=[getResTypeInner getReference]}

TypeRefNode ::= TypeReferenceExpression QualifiedTypeReferenceExpression?
TypeReferenceExpression ::= identifier { methods=[getReference getQualifier] }
left QualifiedTypeReferenceExpression ::= '.' identifier {elementType=TypeReferenceExpression}

RecordTypeNode ::= 'Record' RecordVarDeclGroup* 'end'

OperationStatementBlock ::= OperationStatement*

private OperationStatement ::= Statement {recoverWhile=StatementRecover}

Statement ::= SimpleStatement
private StatementRecover ::= !(':=')
SimpleStatement ::=
    (ProgExpression (AssignmentStatement /*|SwapStatement*/)) {pin(".*")=LeftHandExprList}

left AssignmentStatement ::= ':=' ProgExpression {pin=1}

ProgExpression ::= ' '
/*Statement ::=
          SimpleStatement
        | WhileStmt //{methods=[processDeclarations]}

WhileStmt ::= 'While'

SimpleStatement ::= AssignmentStatement

ExpressionWithRecover ::=

left AssignmentStatement ::= ':=' ExpressionWithRecover {pin=1}
*/
//assignStmt
//swapStmt

ParameterMode ::=
      'alters'
    | 'updates'
    | 'clears'
    | 'restores'
    | 'preserves'
    | 'replaces'
    | 'evaluates'
    | identifier //TODO: not sure about the pin here...