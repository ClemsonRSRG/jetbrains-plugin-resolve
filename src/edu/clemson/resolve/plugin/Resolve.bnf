{
    parserClass='edu.clemson.resolve.plugin.parser.ResParser'

    implements='edu.clemson.resolve.plugin.psi.ResCompositeElement'
    extends='edu.clemson.resolve.plugin.psi.impl.ResCompositeElementImpl'
  
    elementTypeHolderClass='edu.clemson.resolve.plugin.ResTypes'
    elementTypeClass='edu.clemson.resolve.plugin.psi.ResCompositeElementType'
    tokenTypeClass='edu.clemson.resolve.plugin.psi.ResTokenType'
  
    psiClassPrefix='Res'
    psiImplClassSuffix='Impl'
    psiPackage='edu.clemson.resolve.plugin.psi'
    psiImplPackage='edu.clemson.resolve.plugin.psi.impl'
    psiImplUtilClass="edu.clemson.resolve.plugin.psi.impl.ResPsiImplUtil"
    //parserUtilClass="com.goide.parser.GoParserUtil"

    tokens=[
        LBRACE                  = '{'
        RBRACE                  = '}'
        LBRACK                  = '['
        RBRACK                  = ']'
        LPAREN                  = '('
        RPAREN                  = ')'
        COLON                   = ':'
        SEMICOLON               = ';'
        COMMA                   = ','
        COLONEQUALS             = ':='

        EQUALS                  = '='
        TRIPLE_DOT              = '...'
        DOT                     = '.'

        INT                     = 'int'
        FACILITY                = 'Facility'
        CONCEPT                 = 'Concept'
        END                     = 'end'
        EVALUATES               = 'evaluates'
        USES                    = 'uses'
        IS                      = 'is'
        EXTERNALLY              = 'externally'
        IMPLEMENTED             = 'implemented'
        TYPE                    = 'Type'
        FAMILY                  = 'Family'
        MODELED                 = 'modeled'
        EXEMPLAR                = 'exemplar'
        OPERATION               = 'Operation'
        RECURSIVE               = 'Recursive'
        RECORD                  = 'Record'
        PROCEDURE               = 'Procedure'
        VAR                     = 'Var'
        BY                      = 'by'
        STRING                  = 'string'
        CHAR                    = 'char'
        raw_string              = "raw_string"

        //these two are for grammarkit's live preview feature
        //otherwise disregard
        space                   = "regexp:\s+"
        identifier              = 'regexp:\p{Alpha}\w*'
    ]

    extends("(Facility|Concept)Module")="edu.clemson.resolve.plugin.psi.impl.ResAbstractModuleImpl"
    extends("(OperationProcedure)Decl")="edu.clemson.resolve.plugin.psi.impl.ResOperationLikeNodeImpl"
    extends("(Facility)Decl|(Uses)Spec")="edu.clemson.resolve.plugin.psi.impl.ResNamedElementImpl"
    extends("VarDef")="edu.clemson.resolve.plugin.psi.impl.ResNamedElementImpl"
    implements("(Facility|Concept)Block")="edu.clemson.resolve.plugin.psi.ResModuleBlock"
    implements("(OperationProcedure)Decl")="edu.clemson.resolve.plugin.psi.ResOperationLikeNode"
    implements("(Var|Param)Def|(Facility)Decl|(Uses)Spec")="edu.clemson.resolve.plugin.psi.ResNamedElement"
    implements("(Facility|Concept)Module")="edu.clemson.resolve.plugin.psi.ResModule"
    generateTokenAccessors=true
    pin('.*List(?:_\d.*)?')=1
}

Module ::= FacilityModule <<eof>>

FacilityModule ::= 'Facility' identifier ';'
UsesList?
FacilityBlock
'end' identifier ';' {pin(".*")=1}

UsesList ::= 'uses' UsesSpec (',' UsesSpec)* ';' {recoverWhile=UsesListRecover}
private UsesListRecover ::= !(FacilityItem|';'|'end')

UsesSpec ::= identifier

FacilityBlock ::= FacilityItem*

private FacilityItem ::= OperationProcedureDecl {pin=1 recoverWhile=FacilityItemRecover}

private FacilityItemRecover ::= !('end'|'Operation')

OperationProcedureDecl ::= 'Operation' identifier Signature? ';'
ProcedureBody
'end' identifier ';' {pin=1}

Signature ::= Parameters Result? {pin=1}

Result ::= ':' TypeRefNode {pin=1}

Parameters ::= '(' /*ParameterList*/ ')' { pin=1 }
/*private ParameterList ::= ParameterDeclaration (',' (ParameterDeclaration | &')'))* {pin(".*")=1}
ParameterDeclaration ::= ParamDefinitionListNoPin? '...'? Type | Type { // todo: use left rule
  stubClass="com.goide.stubs.GoParameterDeclarationStub"
  methods = [isVariadic]
}
private ParamDefinitionListNoPin ::= ParamDefinition &(!('.' | ')')) (',' ParamDefinition)*
*/

ProcedureBody ::= 'Procedure'
VarDeclGroup* {pin=1 recoverWhile=ProcedureRec}

ProcedureRec ::= !('end')
VarDeclGroup ::= 'Var' VarSpec ';' {pin=1}
VarSpec ::= VarDefList ':' TypeRefNode //{methods=[processDeclarations]}
private VarDefList ::= VarDef (',' VarDef)*

VarDef ::= identifier //{methods=[getResTypeInner getReference]}

TypeRefNode ::= TypeReferenceExpression QualifiedTypeReferenceExpression?
TypeReferenceExpression ::= identifier //{ methods=[getReference getQualifier] }
left QualifiedTypeReferenceExpression ::= '.' identifier {elementType=TypeReferenceExpression}